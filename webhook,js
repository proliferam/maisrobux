import express from "express";
import { buscarPagamento } from "./mercadopago.js";
import { atualizarStatus, buscarPedidoPorPagamentoId, atualizarEstatisticasAfiliado } from "./database.js";
import { Client, GatewayIntentBits, EmbedBuilder, Colors } from "discord.js";


const app = express();
app.use(express.json());

// Inicializar cliente Discord para enviar mensagens
const discordClient = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages]
});

// Conectar ao Discord (apenas para envio de mensagens)
discordClient.login(process.env.DISCORD_TOKEN).catch(console.error);

discordClient.once('ready', () => {
  console.log('ğŸ¤– Bot de webhook conectado ao Discord');
});

// ================================================================
// ğŸŒ WEBHOOK MERCADO PAGO
// ================================================================
app.post("/mercadopago-webhook", async (req, res) => {
  console.log("ğŸ“© Webhook recebido:", req.body);

  try {
    const { type, data } = req.body;
    
    if (type === "payment") {
      const pagamentoId = data.id;
      if (!pagamentoId) return res.sendStatus(200);

      // Buscar detalhes do pagamento
      const pagamento = await buscarPagamento(pagamentoId);
      
      if (!pagamento) {
        console.log("âŒ Pagamento nÃ£o encontrado:", pagamentoId);
        return res.sendStatus(200);
      }

      // Buscar pedido no banco de dados
      const pedido = await buscarPedidoPorPagamentoId(pagamentoId);
      
      if (!pedido) {
        console.log("âŒ Pedido nÃ£o encontrado para pagamento:", pagamentoId);
        return res.sendStatus(200);
      }

      const pedidoData = pedido.fields;
      
      // Atualizar status conforme o status do pagamento
      let novoStatus = "Pendente";
      if (pagamento.status === "approved") {
        novoStatus = "Pago";
      } else if (pagamento.status === "cancelled") {
        novoStatus = "Cancelado";
      } else if (pagamento.status === "refunded") {
        novoStatus = "Reembolsado";
      }
      
      await atualizarStatus(pagamentoId, novoStatus);

      // Enviar para canais do Discord
      if (discordClient.isReady()) {
        const channelPendentes = await discordClient.channels.fetch(process.env.CHANNEL_PENDENTES).catch(() => null);
        const channelPagos = await discordClient.channels.fetch(process.env.CHANNEL_PAGOS).catch(() => null);
        const channelEntregues = await discordClient.channels.fetch(process.env.CHANNEL_ENTREGUES).catch(() => null);

        if (pagamento.status === "approved") {
          console.log("âœ… Pagamento aprovado:", pagamentoId);
          
          // Enviar para canal de pagos
          if (channelPagos) {
            const embed = new EmbedBuilder()
              .setTitle("âœ… PAGAMENTO APROVADO")
              .setColor(Colors.Green)
              .addFields(
                { name: "ğŸ“‹ ID do Pedido", value: pagamentoId, inline: true },
                { name: "ğŸ‘¤ Cliente", value: pedidoData.RobloxUser || "NÃ£o informado", inline: true },
                { name: "ğŸ’° Valor", value: `R$ ${pedidoData.Valor}`, inline: true },
                { name: "ğŸ® Robux", value: pedidoData.Robux?.toString() || "0", inline: true },
                { name: "ğŸ“… Data", value: new Date().toLocaleString("pt-BR"), inline: true },
                { name: "ğŸ« Cupom", value: pedidoData.Cupom || "Nenhum", inline: true },
                { name: "ğŸ¤ Afiliado", value: pedidoData.Afiliado || "Nenhum", inline: true }
              )
              .setTimestamp();

            await channelPagos.send({ embeds: [embed] });
          }

          // Atualizar estatÃ­sticas do afiliado
          if (pedidoData.AfiliadoId && pedidoData.Valor) {
            await atualizarEstatisticasAfiliado(pedidoData.AfiliadoId, pedidoData.Valor);
          }

          // Enviar mensagem para o cliente
          if (pedidoData.DiscordId) {
            try {
              const user = await discordClient.users.fetch(pedidoData.DiscordId);
              if (user) {
                await user.send({
                  embeds: [{
                    title: "âœ… Pagamento Aprovado!",
                    description: `Seu pagamento de **R$ ${pedidoData.Valor}** foi aprovado!\n\n` +
                                 `**Detalhes do Pedido:**\n` +
                                 `â€¢ Robux: ${pedidoData.Robux}\n` +
                                 `â€¢ ID do Pedido: ${pagamentoId}\n` +
                                 `â€¢ Data: ${new Date().toLocaleString('pt-BR')}\n\n` +
                                 `Aguarde a entrega dos Robux!`,
                    color: Colors.Green,
                    timestamp: new Date()
                  }]
                });
              }
            } catch (error) {
              console.log("âŒ NÃ£o foi possÃ­vel enviar DM para o usuÃ¡rio:", error);
            }
          }

        } else if (pagamento.status === "pending" || pagamento.status === "in_process") {
          // Enviar para canal de pendentes
          if (channelPendentes) {
            const embed = new EmbedBuilder()
              .setTitle("â³ PAGAMENTO PENDENTE")
              .setColor(Colors.Yellow)
              .addFields(
                { name: "ğŸ“‹ ID do Pedido", value: pagamentoId, inline: true },
                { name: "ğŸ‘¤ Cliente", value: pedidoData.RobloxUser || "NÃ£o informado", inline: true },
                { name: "ğŸ’° Valor", value: `R$ ${pedidoData.Valor}`, inline: true },
                { name: "ğŸ® Robux", value: pedidoData.Robux?.toString() || "0", inline: true },
                { name: "ğŸ“… Data", value: new Date().toLocaleString("pt-BR"), inline: true },
                { name: "ğŸ« Cupom", value: pedidoData.Cupom || "Nenhum", inline: true }
              )
              .setTimestamp();

            await channelPendentes.send({ embeds: [embed] });
          }
        }
      }
    }
  } catch (error) {
    console.error("âŒ Erro ao processar webhook:", error);
  }

  res.sendStatus(200);
});

// ================================================================
// ğŸ”„ WEBHOOK PARA MARCAR COMO ENTREGUE
// ================================================================
app.post("/marcar-entregue", async (req, res) => {
  try {
    const { pagamentoId } = req.body;
    
    if (!pagamentoId) {
      return res.status(400).json({ error: "ID do pagamento Ã© obrigatÃ³rio" });
    }

    // Atualizar status para entregue
    await atualizarStatus(pagamentoId, "Entregue");

    // Mover para canal de entregues
    if (discordClient.isReady()) {
      const channelEntregues = await discordClient.channels.fetch(process.env.CHANNEL_ENTREGUES).catch(() => null);
      
      if (channelEntregues) {
        const pedido = await buscarPedidoPorPagamentoId(pagamentoId);
        
        if (pedido) {
          const embed = new EmbedBuilder()
            .setTitle("ğŸ PEDIDO ENTREGUE")
            .setColor(Colors.Green)
            .addFields(
              { name: "ğŸ“‹ ID do Pedido", value: pagamentoId, inline: true },
              { name: "ğŸ‘¤ Cliente", value: pedido.fields.RobloxUser || "NÃ£o informado", inline: true },
              { name: "ğŸ’° Valor", value: `R$ ${pedido.fields.Valor}`, inline: true },
              { name: "ğŸ® Robux", value: pedido.fields.Robux?.toString() || "0", inline: true },
              { name: "ğŸ“… Data de Entrega", value: new Date().toLocaleString("pt-BR"), inline: true },
              { name: "ğŸ¤ Afiliado", value: pedido.fields.Afiliado || "Nenhum", inline: true }
            )
            .setTimestamp();

          await channelEntregues.send({ embeds: [embed] });
        }
      }
    }

    res.json({ success: true, message: "Pedido marcado como entregue" });
  } catch (error) {
    console.error("âŒ Erro ao marcar como entregue:", error);
    res.status(500).json({ error: "Erro interno do servidor" });
  }
});

// ================================================================
// ğŸ“Š ENDPOINTS PARA DASHBOARD
// ================================================================
app.get("/estatisticas", async (req, res) => {
  try {
    const estatisticas = await obterEstatisticas();
    res.json(estatisticas);
  } catch (error) {
    console.error("Erro ao buscar estatÃ­sticas:", error);
    res.status(500).json({ error: "Erro interno" });
  }
});

app.get("/afiliados", async (req, res) => {
  try {
    const afiliados = await listarAfiliados();
    res.json(afiliados);
  } catch (error) {
    console.error("Erro ao buscar afiliados:", error);
    res.status(500).json({ error: "Erro interno" });
  }
});

app.listen(3000, () => {
  console.log("ğŸŒ Webhook ativo na porta 3000");
});
